<!DOCTYPE html>
<html>
<head>
    <title>WebRTC å¤šæ–¹é€£ç·šä¿¡ä»¤ç¯„ä¾‹ - æ¨¡çµ„åˆ†é›¢èˆ‡ç‹€æ…‹é¡¯ç¤º</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        textarea { width: 100%; margin-bottom: 10px; padding: 5px; box-sizing: border-box; }
        button { margin-right: 10px; padding: 10px 15px; cursor: pointer; }
        #messages { margin-top: 20px; border: 1px solid #ccc; padding: 10px; max-height: 300px; overflow-y: auto; }
        .log-id { font-weight: bold; color: blue; }
        .auto-connect-btn { background-color: #4CAF50; color: white; border: none; }
        .status-dot { height: 12px; width: 12px; background-color: grey; border-radius: 50%; display: inline-block; margin-right: 5px; }
        .status-connected { background-color: green; }
        .status-disconnected { background-color: red; }
        #roleSelection button { font-weight: bold; }
        .hub-btn { background-color: darkred; color: white; }
        .spoke-btn { background-color: darkgreen; color: white; }
        
        /* WebRTC ç‹€æ…‹åˆ—è¡¨æ¨£å¼ */
        #peerStatusList { border: 1px solid #ddd; padding: 10px; list-style: none; margin-top: 10px; }
        #peerStatusList li { margin-bottom: 5px; padding-bottom: 5px; border-bottom: 1px dotted #eee; }
        .status-ok { color: green; font-weight: bold; }
        .status-warn { color: orange; }
        .status-err { color: red; }
    </style>
</head>
<body>
    <h1>WebRTC ä¿¡ä»¤å®¢æˆ¶ç«¯ (æ˜Ÿç‹€ç¶²è·¯)</h1>
    
    <h2>æ­¥é©Ÿ 1: è¨­å®šè§’è‰²ä¸¦å•Ÿå‹•é€£ç·š</h2>
    <div id="roleSelection">
        <p>è«‹å…ˆæ±ºå®šç•¶å‰è¦–çª—çš„è§’è‰²ï¼š</p>
        <button class="hub-btn" onclick="setRoleAndStart('hub')">ğŸ‘‘ è¨­å®šç‚º HUB (ä¸­å¿ƒ)</button>
        <button class="spoke-btn" onclick="setRoleAndStart('spoke')">âš™ï¸ è¨­å®šç‚º SPOKE (å®¢æˆ¶ç«¯)</button>
    </div>
    
    <h2>æ­¥é©Ÿ 2: ç‹€æ…‹ç¸½è¦½</h2>
    <p>
        <span class="status-dot" id="wsStatusDot"></span>
        <span class="log-id">æˆ‘çš„ ID:</span> <span id="clientIdDisplay">...</span>
        <br>WebSocket ç‹€æ…‹: <span id="wsStatusText">æœªé€£ç·š</span>
        <br>ğŸ‘‰ **æˆ‘çš„è§’è‰²**: <span id="clientRoleDisplay" style="font-weight: bold; color: darkorange;">æœªè¨­å®š</span>
    </p>

    <h3>WebRTC P2P é€£ç·šç‹€æ…‹</h3>
    <ul id="peerStatusList">
        <li>å°šæœªå»ºç«‹ä»»ä½• P2P é€£ç·šã€‚</li>
    </ul>

    <h2>æ­¥é©Ÿ 3: æ“ä½œ</h2>
    <div id="operations" style="display: none;">
        <button onclick="webrtcClient.sendSdpOffer()">å‚³é€ Offer (éœ€è¼¸å…¥ç›®æ¨™ ID)</button>
        <button class="auto-connect-btn" onclick="webrtcClient.connectAllOnlineUsers()">âš¡ï¸ [åƒ… HUB ä½¿ç”¨] é€£ç·šæ‰€æœ‰åœ¨ç·šç”¨æˆ¶</button>
        <button onclick="webrtcClient.sendChatMessage()">ç¾¤ç™¼è¨Šæ¯</button>
    </div>
    

    <h2>SDP è³‡è¨Š (ç”¨æ–¼é™¤éŒ¯)</h2>
    <textarea id="localSdp" placeholder="æœ¬åœ° SDP" rows="5" readonly></textarea>
    <textarea id="remoteSdp" placeholder="é ç«¯ SDP (æœ€å¾Œæ¥æ”¶çš„ Offer/Answer)" rows="5" readonly></textarea>

    <h2>è¨Šæ¯è¨˜éŒ„</h2>
    <div id="messages"></div>

    <script>
        // ----------------------------------------------------
        // 1. å…¨åŸŸè¨­å®šèˆ‡ UI è®Šæ•¸ (ä¾› WebRTCClient è®€å–)
        // ----------------------------------------------------
        
        const WS_URL = 'wss://loa-boss-ws-server.onrender.com/ws';
        const HUB_FIXED_ID = 'HUB_A_FIXED_ID';
        
        let MY_ROLE = null;
        let MY_CLIENT_ID = null;
        let webrtcClient = null;
        
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }
            ]
        };
        
        // ğŸ”¥ UI å‡½æ•¸é›†åˆ - å°‡æ‰€æœ‰ DOM æ“ä½œé›†ä¸­åœ¨æ­¤ï¼Œä¾›æ¨¡çµ„å‘¼å«
        const UIManager = {
            appendMessage(msg) {
                const container = document.getElementById('messages');
                container.innerHTML += `<p>${msg}</p>`;
                container.scrollTop = container.scrollHeight;
            },

            updateWsStatus(status) {
                const dot = document.getElementById('wsStatusDot');
                const text = document.getElementById('wsStatusText');
                
                dot.className = 'status-dot';
                if (status === 'connected') {
                    dot.classList.add('status-connected');
                    text.textContent = 'é€£ç·šæˆåŠŸ';
                } else if (status === 'connecting') {
                    text.textContent = 'å˜—è©¦é€£ç·šä¸­...';
                } else if (status === 'disconnected') {
                    dot.classList.add('status-disconnected');
                    text.textContent = 'å·²æ–·ç·š/é€£ç·šå¤±æ•—';
                } else {
                    text.textContent = 'æœªé€£ç·š';
                }
            },
            
            updateSdpDisplay(type, sdp) {
                if (type === 'local') {
                    document.getElementById('localSdp').value = JSON.stringify(sdp, null, 2);
                } else if (type === 'remote') {
                    document.getElementById('remoteSdp').value = JSON.stringify(sdp, null, 2);
                }
            },
            
            updatePeerStatus(peerId, iceState, dataChannelState) {
                const list = document.getElementById('peerStatusList');
                let listItem = document.getElementById(`peer-${peerId}`);

                if (!listItem) {
                    listItem = document.createElement('li');
                    listItem.id = `peer-${peerId}`;
                    list.appendChild(listItem);
                    
                    if (list.querySelector('li').textContent === 'å°šæœªå»ºç«‹ä»»ä½• P2P é€£ç·šã€‚') {
                        list.removeChild(list.querySelector('li'));
                    }
                }
                
                let iceClass = 'status-warn';
                if (iceState === 'connected' || iceState === 'completed') {
                    iceClass = 'status-ok';
                } else if (iceState === 'failed' || iceState === 'closed') {
                    iceClass = 'status-err';
                }

                let dcClass = 'status-warn';
                if (dataChannelState === 'open') {
                    dcClass = 'status-ok';
                } else if (dataChannelState === 'closed' || dataChannelState === 'none') {
                    dcClass = 'status-err';
                }
                
                // ICE connected/completed ä½† DC è™•æ–¼ connecting/closingï¼Œç¶­æŒæ©˜è‰²è­¦å‘Š
                if ((iceState === 'connected' || iceState === 'completed') && 
                    (dataChannelState === 'connecting' || dataChannelState === 'closing')) {
                    dcClass = 'status-warn';
                }

                listItem.innerHTML = `
                    **å°æ‰‹ ID:** ${peerId}
                    <br>
                    ICE ç‹€æ…‹: <span class="${iceClass}">${iceState}</span> | 
                    DC ç‹€æ…‹: <span class="${dcClass}">${dataChannelState}</span>
                `;
                
                if (iceState === 'closed' || iceState === 'failed') { 
                     // å»¶é²ç§»é™¤ï¼Œè®“ç”¨æˆ¶çœ‹åˆ°æœ€çµ‚ç‹€æ…‹
                     setTimeout(() => {
                         const finalItem = document.getElementById(`peer-${peerId}`);
                         if (finalItem) {
                             list.removeChild(finalItem);
                             if (list.children.length === 0) {
                                list.innerHTML = '<li>å°šæœªå»ºç«‹ä»»ä½• P2P é€£ç·šã€‚</li>';
                             }
                         }
                     }, 5000); 
                }
            }
        };

        // ----------------------------------------------------
        // 2. WebRTC å®¢æˆ¶ç«¯æ¨¡çµ„ (ç¨ç«‹æ–¼ UI)
        // ----------------------------------------------------

        const WebRTCClientModule = (function() {
            class WebRTCClient {
                constructor(clientId, wsUrl, config, role, uiManager) {
                    this.clientId = clientId;
                    this.wsUrl = wsUrl;
                    this.config = config;
                    this.role = role;
                    this.ui = uiManager;
                    this.ws = null;
                    this.peerConnections = new Map();
                    this.dataChannels = new Map();
                    this.reconnectInterval = 3000;
                    this.reconnectAttempts = 0;
                }

                // --- WebSocket é€£ç·šèˆ‡é‡é€£æ©Ÿåˆ¶ ---

                startConnection() {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ui.appendMessage("<span style='color: orange;'>WebSocket å·²é€£ç·šï¼Œç„¡éœ€é‡è¤‡å•Ÿå‹•ã€‚</span>");
                        return;
                    }
                    this._connectWebSocket();
                }

                _connectWebSocket() {
                    this.ui.updateWsStatus('connecting');
                    this.ui.appendMessage(`å˜—è©¦é€£ç·šåˆ°ä¿¡ä»¤ä¼ºæœå™¨: ${this.wsUrl}`);
                    
                    try {
                        this.ws = new WebSocket(this.wsUrl);
                    } catch (e) {
                        this.ui.appendMessage(`<span style='color: red;'>WebSocket å»ºç«‹å¤±æ•—: ${e.message}</span>`);
                        this._scheduleReconnect();
                        return;
                    }

                    this.ws.onopen = () => {
                        this.reconnectAttempts = 0;
                        this.ui.updateWsStatus('connected');
                        
                        const registrationMessage = {
                            type: 'client_register', 
                            senderId: this.clientId
                        };
                        this.ws.send(JSON.stringify(registrationMessage));
                        this.ui.appendMessage(`<span style="color: grey;">ä¿¡ä»¤é€£ç·šæˆåŠŸï¼ŒID: ${this.clientId} (${this.role.toUpperCase()}) å·²ç™¼é€è¨»å†Šè«‹æ±‚ã€‚</span>`);

                        // HUB åœ¨ WS é€£ä¸Šå¾Œï¼Œä¸»å‹•é€£ç·šæ‰€æœ‰åœ¨ç·šç”¨æˆ¶
                        if (this.role === 'hub') {
                            this.connectAllOnlineUsers();
                        }
                    };

                    this.ws.onmessage = (event) => this._handleWebSocketMessage(event);

                    this.ws.onclose = () => {
                        this.ui.updateWsStatus('disconnected');
                        this.ui.appendMessage("<span style='color: red;'>WebSocket é€£ç·šå·²é—œé–‰ã€‚</span>");
                        this._scheduleReconnect();
                    };
                    
                    this.ws.onerror = (err) => {
                        console.error("WebSocket éŒ¯èª¤:", err);
                        this.ui.updateWsStatus('disconnected');
                        this.ws.close();
                    };
                }
                
                _scheduleReconnect() {
                    // æª¢æŸ¥ WebSocket æ˜¯å¦çœŸçš„å·²é—œé–‰
                    if (!this.ws || this.ws.readyState !== WebSocket.CLOSED) {
                        return;
                    }
                    
                    // HUB é‡é€£é‚è¼¯ (ä¿æŒä¸è®Šï¼ŒHUB æ°¸é è¦å˜—è©¦é‡é€£)
                    if (this.role === 'hub') {
                        this.reconnectAttempts++;
                        this.ui.appendMessage(`<span style='color: red;'>[HUB] å°‡åœ¨ ${this.reconnectInterval / 1000} ç§’å¾Œå˜—è©¦ç¬¬ ${this.reconnectAttempts} æ¬¡é‡é€£...</span>`);
                        setTimeout(() => this._connectWebSocket(), this.reconnectInterval);
                        return;
                    } 
                    
                    // ğŸ”¥ ä¿®æ­£ï¼šSPOKE é‡é€£é‚è¼¯ï¼šæª¢æŸ¥ DataChannel Map æ˜¯å¦ç‚ºç©º
                    if (this.role === 'spoke') {
                        // åˆ¤æ–· dataChannels Map æ˜¯å¦ç‚ºç©ºï¼ˆè¡¨ç¤ºæ²’æœ‰ä»»ä½•æ´»èºæˆ–æº–å‚™æ´»èºçš„ P2P é€£ç·šï¼‰
                        if (this.dataChannels.size === 0) {
                             // æ‰€æœ‰ P2P éƒ½æ–·äº†ï¼ŒSPOKE å¿…é ˆé‡é€£ WSï¼Œç­‰å¾… HUB ç™¼èµ· Offer
                             this.reconnectAttempts++;
                             this.ui.appendMessage(`<span style='color: red;'>[SPOKE] P2P æ–·ç·šï¼Œå°‡åœ¨ ${this.reconnectInterval / 1000} ç§’å¾Œå˜—è©¦ç¬¬ ${this.reconnectAttempts} æ¬¡é‡é€£ WS...</span>`);
                             setTimeout(() => this._connectWebSocket(), this.reconnectInterval);
                        } else {
                             // ä»æœ‰ P2P é€£ç·šå­˜åœ¨ï¼Œä¸é‡é€£ WS
                             this.ui.appendMessage("<span style='color: orange;'>[SPOKE] WebSocket é€£ç·šå·²é—œé–‰ã€‚ä½†ä»æœ‰ P2P é€£ç·šæ´»èºï¼Œä¸é‡é€£ WSã€‚</span>");
                        }
                    }
                }


                // --- WebSocket è¨Šæ¯è™•ç† ---

                async _handleWebSocketMessage(event) {
                    const signal = JSON.parse(event.data);
                    
                    if (signal.senderId === this.clientId) return;
                    
                    if (signal.type === 'user_joined') {
                        const newUserId = signal.newUserId;
                        
                        if (newUserId !== this.clientId) {
                            if (this.role === 'hub') {
                                this.ui.appendMessage(`<span style='color: blue;'>ğŸ“£ [HUB] åµæ¸¬åˆ°æ–°ç”¨æˆ¶ [${newUserId}] ä¸Šç·šï¼Œè‡ªå‹•ç™¼èµ·é€£ç·š...</span>`);
                                await this.sendSdpOffer(newUserId); 
                            } else {
                                this.ui.appendMessage(`<span style='color: blue;'>ğŸ“£ [SPOKE] åµæ¸¬åˆ°æ–°ç”¨æˆ¶ [${newUserId}] ä¸Šç·šï¼Œéœå¾… Offerã€‚</span>`);
                            }
                        }
                        return;
                    }
                    
                    if (signal.type === 'online_users_list') {
                        const userIds = signal.users || [];
                        
                        if (this.role !== 'hub') return; 

                        this.ui.appendMessage(`<span style='color: purple;'>[HUB] æ”¶åˆ° ${userIds.length} å€‹åœ¨ç·šç”¨æˆ¶ IDï¼Œé–‹å§‹å»ºç«‹é€£ç·š...</span>`);
                        
                        userIds.forEach(async (targetId) => {
                            // ä¿®æ­£ï¼šæª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰ P2P é€£ç·šåœ¨å»ºç«‹æˆ–å·²ç¶“é–‹å•Ÿ
                            const isConnectingOrOpen = this.dataChannels.has(targetId) && 
                                (this.dataChannels.get(targetId).readyState === 'open' || 
                                 this.dataChannels.get(targetId).readyState === 'connecting');
                                 
                            if (targetId !== this.clientId && !isConnectingOrOpen) {
                                console.log(`[HUB] ç‚ºç›®æ¨™ ${targetId} è‡ªå‹•ç™¼é€ Offer...`);
                                await this.sendSdpOffer(targetId); 
                            }
                        });
                        return;
                    }

                    const peerId = signal.senderId;
                    const pc = this._getOrCreatePeerConnection(peerId, false);
                    
                    switch (signal.type) {
                        case 'offer':
                            await pc.setRemoteDescription(new RTCSessionDescription(signal));
                            this.ui.updateSdpDisplay('remote', signal);
                            this._sendSdpAnswer(peerId); 
                            break;
                        case 'answer':
                            if (pc.signalingState === 'stable' && pc.remoteDescription) return; 
                            await pc.setRemoteDescription(new RTCSessionDescription(signal));
                            this.ui.updateSdpDisplay('remote', signal);
                            break;
                        case 'candidate':
                            if (signal.candidate) {
                                try {
                                    await pc.addIceCandidate(new RTCIceCandidate(signal.candidate));
                                } catch (e) {
                                    console.error("æ·»åŠ  ICE å€™é¸å¤±æ•—:", e);
                                }
                            }
                            break;
                    }
                }
                
                // --- WebRTC é€£ç·šèˆ‡å”å•† ---
                
                _getOrCreatePeerConnection(id, isCaller) {
                    if (this.peerConnections.has(id)) {
                        return this.peerConnections.get(id);
                    }

                    const pc = new RTCPeerConnection(this.config);
                    
                    pc.onicecandidate = (event) => {
                        if (event.candidate && this.ws && this.ws.readyState === WebSocket.OPEN) {
                            this.ws.send(JSON.stringify({
                                type: 'candidate',
                                candidate: event.candidate,
                                senderId: this.clientId,
                                targetId: id
                            }));
                        }
                    };
                    
                    pc.oniceconnectionstatechange = () => {
                        console.log(`[${id}] ICE Connection State: ${pc.iceConnectionState}`);
                        const dcState = this.dataChannels.get(id) ? this.dataChannels.get(id).readyState : 'none';
                        this.ui.updatePeerStatus(id, pc.iceConnectionState, dcState);
                        
                        // ğŸ”¥ ä¿®æ­£é» 1: ç¢ºä¿ ICE å¤±æ•—æˆ–é—œé–‰æ™‚ï¼Œæ¸…ç† Maps ä¸¦æª¢æŸ¥ SPOKE æ˜¯å¦éœ€è¦é‡é€£ WS
                        if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'closed') {
                            const dc = this.dataChannels.get(id);
                            // ç›¡å¯èƒ½é—œé–‰ä¸¦æ¸…ç† DataChannelï¼Œä»¥ç¢ºä¿ _scheduleReconnect çš„åˆ¤æ–·æ­£ç¢º
                            if (dc && dc.readyState !== 'closed') {
                                dc.close(); 
                            }
                            
                            this.peerConnections.delete(id);
                            this.dataChannels.delete(id);

                            // å¦‚æœæ˜¯ SPOKE ä¸” WS å·²ç¶“æ–·ç·šï¼Œå‰‡è§¸ç™¼é‡é€£æª¢æŸ¥
                            if (this.role === 'spoke' && (!this.ws || this.ws.readyState === WebSocket.CLOSED)) {
                                this._scheduleReconnect(); 
                            }
                        }
                    };
                    
                    if (!isCaller) {
                        pc.ondatachannel = (event) => {
                            const channel = event.channel;
                            this.dataChannels.set(id, channel);
                            this._setupDataChannel(channel, id); 
                        };
                    }

                    this.peerConnections.set(id, pc);
                    
                    if (isCaller) {
                        const channel = pc.createDataChannel('chat');
                        this.dataChannels.set(id, channel);
                        this._setupDataChannel(channel, id);
                    }

                    return pc;
                }

                _setupDataChannel(channel, id) { 
                    channel.onopen = () => {
                        this.ui.appendMessage(`<span style="color: green;">æ•¸æ“šé€šé“å·²é€£ç·šï¼èˆ‡ [${id}]</span>`);
                        this.ui.updatePeerStatus(id, this.peerConnections.get(id).iceConnectionState, channel.readyState);
                        
                        // SPOKE æ–·é–‹ WS é‚è¼¯ 
                        if (this.role === 'spoke' && this.ws && this.ws.readyState === WebSocket.OPEN) {
                            this.ui.appendMessage(`<span style="color: orange;">[SPOKE] P2P é€£ç·šæˆåŠŸï¼Œæ­£åœ¨ä¸­æ–· WebSocket ä¿¡ä»¤é€£ç·š...</span>`);
                            this.ws.close();
                        }
                    };
                    channel.onmessage = (event) => {
                        this.ui.appendMessage(`[${id}] å°æ–¹: ${event.data}`);
                    };
                    channel.onclose = () => {
                        this.ui.appendMessage(`<span style="color: orange;">[${id}] æ•¸æ“šé€šé“å·²é—œé–‰ã€‚</span>`);
                        this.dataChannels.delete(id);
                        
                        // æª¢æŸ¥ PC æ˜¯å¦ä»ç„¶å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨å‰‡æ›´æ–° UI
                        const pc = this.peerConnections.get(id);
                        if (pc) {
                            this.ui.updatePeerStatus(id, pc.iceConnectionState, channel.readyState);
                            
                            // å³ä½¿ DC é—œé–‰ï¼Œå¦‚æœ ICE ä»ç„¶é€£ç·šï¼Œä¹Ÿè¦ç¢ºä¿è§¸ç™¼æ¸…ç†æˆ–é‡é€£æª¢æŸ¥
                            if (pc.iceConnectionState === 'connected' && this.role === 'spoke' && this.dataChannels.size === 0) {
                                // é€™æ˜¯å€‹ç½•è¦‹çš„æƒ…æ³ï¼Œç†è«–ä¸Š ICE ä¹Ÿæœƒå¾ˆå¿«æ–·ç·šï¼Œä½†ç‚ºäº†ä¿éšªï¼Œå†æ¬¡æª¢æŸ¥é‡é€£
                                this._scheduleReconnect(); 
                            }
                        }
                    }
                    channel.onerror = (error) => {
                        this.ui.appendMessage(`<span style="color: red;">[${id}] æ•¸æ“šé€šé“éŒ¯èª¤: ${error.message}</span>`);
                    }
                }
                
                async sendSdpOffer(targetId) { 
                    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                        alert("WebSocket å°šæœªé€£ç·šï¼Œè«‹å…ˆé»æ“Š 'è¨­å®šè§’è‰²ä¸¦å•Ÿå‹•é€£ç·š'ã€‚");
                        return;
                    }
                    
                    if (!targetId) {
                        targetId = prompt("è«‹è¼¸å…¥ç›®æ¨™ ID ä¾†ç™¼èµ·é€£ç·š:");
                        if (!targetId) return;
                    }
                    
                    // æª¢æŸ¥ç›®æ¨™é€£ç·šæ˜¯å¦å·²é–‹å•Ÿæˆ–æ­£åœ¨é€£ç·šä¸­
                    const isConnectingOrOpen = this.dataChannels.has(targetId) && 
                        (this.dataChannels.get(targetId).readyState === 'open' || 
                         this.dataChannels.get(targetId).readyState === 'connecting');

                    if (isConnectingOrOpen) {
                        console.warn(`å·²èˆ‡ ${targetId} å»ºç«‹é€£ç·šæˆ–æ­£åœ¨é€£ç·šä¸­ï¼Œè·³é Offerã€‚`);
                        return;
                    }
                    
                    let pc = this._getOrCreatePeerConnection(targetId, true); 

                    try {
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        this.ui.updateSdpDisplay('local', offer);
                        
                        const offerWithId = { 
                            ...offer, 
                            senderId: this.clientId, 
                            targetId: targetId 
                        }; 
                        this.ws.send(JSON.stringify(offerWithId));
                        console.log(`Offer å·²å‚³é€çµ¦ ${targetId}ã€‚`);
                    } catch (error) {
                        console.error("å‰µå»º Offer å¤±æ•—:", error);
                    }
                }

                async _sendSdpAnswer(targetId) { 
                    let pc = this.peerConnections.get(targetId); 

                    try {
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        this.ui.updateSdpDisplay('local', answer);

                        const answerWithId = { 
                            ...answer, 
                            senderId: this.clientId, 
                            targetId: targetId 
                        };
                        this.ws.send(JSON.stringify(answerWithId));
                        console.log(`Answer å·²å‚³é€çµ¦ ${targetId}ã€‚`);
                    } catch (error) {
                        console.error("å‰µå»º Answer å¤±æ•—:", error);
                    }
                }
                
                // --- é¡å¤–åŠŸèƒ½ ---

                connectAllOnlineUsers() {
                    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                        alert("WebSocket å°šæœªé€£ç·šã€‚");
                        return;
                    }
                    
                    if (this.role !== 'hub') {
                        this.ui.appendMessage("<span style='color: orange;'>åªæœ‰ HUB ç¯€é»å¯ä»¥ä½¿ç”¨æ­¤åŠŸèƒ½ã€‚</span>");
                        return;
                    }

                    const request = {
                        type: 'request_online_users',
                        senderId: this.clientId
                    };
                    this.ws.send(JSON.stringify(request));
                    this.ui.appendMessage("<span style='color: purple;'>[HUB] å·²å‘ä¼ºæœå™¨è«‹æ±‚åœ¨ç·šç”¨æˆ¶åˆ—è¡¨...</span>");
                }

                sendChatMessage() {
                    const message = prompt("è«‹è¼¸å…¥è¦ç™¼é€çš„è¨Šæ¯:");
                    if (!message) return;
                    
                    let sentCount = 0;
                    
                    if (this.dataChannels.size === 0) {
                        alert("å°šæœªèˆ‡ä»»ä½•ç”¨æˆ¶é€£ç·šæˆåŠŸã€‚");
                        return;
                    }

                    this.dataChannels.forEach((channel, peerId) => {
                        if (channel.readyState === 'open') {
                            channel.send(message); 
                            sentCount++;
                        }
                    });

                    if (sentCount > 0) {
                        this.ui.appendMessage(`<span style="color: blue;">æˆ‘ (ç™¼é€çµ¦ ${sentCount} å€‹é€£ç·š): ${message}</span>`);
                    } else {
                        alert("æ²’æœ‰ä»»ä½•é–‹æ”¾çš„ DataChannel å¯ä»¥ç™¼é€è¨Šæ¯ã€‚");
                    }
                }
            }
            
            return WebRTCClient;
        })();


        // ----------------------------------------------------
        // 3. å•Ÿå‹•è…³æœ¬ (ä¸»è¦æµç¨‹)
        // ----------------------------------------------------
        
        function setRoleAndStart(role) {
            if (webrtcClient && webrtcClient.ws && webrtcClient.ws.readyState === WebSocket.OPEN) {
                alert("WebSocket å·²é€£ç·šï¼Œè«‹å…ˆé—œé–‰æˆ–é‡æ–°æ•´ç†é é¢ä¾†æ›´æ›è§’è‰²ã€‚");
                return;
            }

            MY_ROLE = role;
            
            if (MY_ROLE === 'hub') {
                MY_CLIENT_ID = HUB_FIXED_ID;
            } else {
                MY_CLIENT_ID = 'SPK_' + Math.random().toString(36).substring(2, 9);
            }

            document.getElementById('clientIdDisplay').textContent = MY_CLIENT_ID;
            document.getElementById('clientRoleDisplay').textContent = MY_ROLE.toUpperCase();
            
            document.getElementById('roleSelection').style.display = 'none';
            document.getElementById('operations').style.display = 'block';

            // å¯¦ä¾‹åŒ–æ¨¡çµ„ï¼Œå°‡ UI Manager å‚³éçµ¦å®ƒ
            webrtcClient = new WebRTCClientModule(MY_CLIENT_ID, WS_URL, configuration, MY_ROLE, UIManager);
            webrtcClient.startConnection();
        }
        
        // åˆå§‹ UI ç‹€æ…‹
        UIManager.updateWsStatus('disconnected');
    </script>
</body>
</html>